<!DOCTYPE HTML>
<html>

<head>
	<title>Angular</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="icon" href="./images/favicon.png" />
</head>

<body class="subpage">

	<!-- Header -->
	<header id="header" class="alt">
		<div class="logo"><a href="index.html">Angular <span>by Florimon Dch</span></a></div>
		<a href="#menu"><span>Menu</span></a>
	</header>

	<!-- Nav -->
	<nav id="menu">
		<ul class="links">
			<li><a href="index.html">Home</a></li>
			<li><a href="java.html">Java</a></li>
			<li><a href="db.html">Bases de données</a></li>
			<li><a href="web.html">Web</a></li>
			<li><a href="javaee.html">Java EE (api servlet et JSP)</a></li>
			<li><a href="service.html">Service Web avec Java SE</a></li>
			<li><a href="jpa.html">JPA Hibernate</a></li>
			<li><a href="outils.html">Outils</a></li>
			<li><a href="spring.html">Spring</a></li>
			<li><a href="angular.html">Angular</a></li>
		</ul>
	</nav>

	<!-- Content -->
	<!--
			Note: To show a background image, set the "data-bg" attribute below
			to the full filename of your image. This is used in each section to set
			the background image.
		-->
	<section id="post" class="wrapper bg-img" data-bg="land7.jpg">
		<div class="inner">
			<article class="box">
				<header>
					<h2>Angular</h2>
					<p>19.03.2020</p>
				</header>
				<div class="content">

					<p>
						<h4>Installation</h4>

						Pour utiliser Angular, il faut d'abord installer NodeJs

						<a href="https://nodejs.org/en/download/">Site Node.js</a>



					</p>
					<p>
						<h4>Commande Angular</h4>

						<code>
								ng serve -o
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<code>
								ng g c nom_composant
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<code>
								ng g class nom_classe
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<code>
								ng g service nom_service
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<code>
								tsc -w
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<code>
								nodemon build/index.js
							</code>
						permet de mettre à jour le repo local avec le repo distant (git pull origin master pouur mettre
						une branche à jour)
						<br>
						<br>

						<h4>TypeScript et ES6</h4>
						<p><b>TypeScript</b> est un langage "surcouche" de ES6 qui est utilisé pour Angular.
							<b>ES6</b> est un standard de langage de programmation, il définit la syntaxe, les types de
							variable, ...


							<h5>Installation </h5>

							Pour installer TypeScript, il faut utiliser <b>npm</b>, un gestionnaire de paquet de Node.js
							qui permet de télécharger facilement des paquest (bibliothèques ou programmes).
							<br>
							<br>
							<code>npm install -g typescript</code> <b>-g</b> indique que l'installation est global à
							tous les projets.
							<br>
							<br>
							<code>tsc --init --target es5 --sourceMap --experimentalDecorators --emitDecoratorMetadata</code>Permet
							de mettre un fichier de configuration pour TypeScript.
							<br>
							<br>
							<code>tsc --watch</code>Indique au transpileur de transformer les fichiers .ts en .js à
							chaque modification de
							ceux-ci.
							<br><br>
							TypeScript n'est pas compris par les navigateur, c'est pour cela qu'il est transpilé en
							JavaScript (généralement ES5).

						</p>
						<h4>Formulaires</h4>
						<p>Il existe différentes façon d'implémenter les formulaires
							avec Angular.
							<ul>
								<li>
									<b>Template-driven Forms</b> (à éviter) : inspirée du "two-way
									binding" utilisé dans AngularJS, cette approche
									a de nombreuses limitations et s'avère rapidement
									fastidieuse à implémenter, peu extensible et peu
									efficace.
								</li>
								<br>
								<li>
									<b>Reactive Forms</b> (à adopter) : cette approche vient
									appuyer le paradigme "Reactive Programming" qui
									fait parti des fondements d'Angular avec : une
									meilleure séparation de la logique du formulaire et
									de la vue, une meilleure testabilité, des Observables,
									la génération dynamique de formulaires etc…
								</li>
							</ul>

							Il est recommandé d'utiliser les reactives forms car ils présentent les avantages suivants :
							<br><br>
							<ul>
								<li>La logique des formulaires se fait dans le code TypeScript. Le formulaire devient
									alors plus facile à tester et à générer
									dynamiquement.</li><br>
								<li>Les "Reactive Forms" utilisent des Observables pour faciliter et encourager le
									<b>"Reactive Programming"</b>.</li>
							</ul>

							<h5>FormControl</h5>

							La classe FormControl permet de contrôler et d'accéder à l'état des "controls" de la vue
							(e.g. &lt;input>).
								<br><br>

								<pre><code>import { FormControl } from "@angular/forms";

export class UserFormComponent {

	userTitleControl = new FormControl();
	userDescriptionControl = new FormControl();

	submitUser() {
	console.log(this.userTitleControl.value);
	console.log(this.userDescriptionControl.value);
	}
}</code></pre>

								<pre><code>&lt;input
	type="text"
	[formControl]="userTitleControl">
&lt;textarea [formControl]="userDescriptionControl">&lt;/textarea>
&lt;button
	type="submit"
	(click)="submitUser()">SUBMIT&lt;/button></code></pre>

								Si nous testons tel quel, il va y avoir une erreur. Il nous faut importer le module <b>«
									ReactiveFormsModule »</b> dans le <b>appmodule.ts</b>.
								<br><br>

								FormControl fournit différentes propriétés et méthodes permettant de piloter le
								"control" :
								<br><br>
								<ul>
									<li>
										<b>value</b> : permet d'accéder à la valeur actuellement contenu dans le «
										control ».
									</li>

									<li>
										<b>valueChanges </b>: est un Observable permettant d'observer les changements de
										valeur du « control".
									</li>

									<li>
										<b>reset, setValue</b> et <b>patchValue</b> permettent de modifier l'état et la
										valeur du « control".
									</li>
								</ul>

								<h5>FormGroup</h5>

								<b>FormGroup</b> permet de regrouper des "controls" afin de faciliter l'implémentation,
								récupérer la valeur groupée des "controls" ou encore appliquer
								des validateurs au groupe.
								<br><br>
								Le FormGroup est construit avec un <b>"plain object"</b> associant chaque propriété à un
								<b>FormControl</b>.<br>
								Il est alors possible d'accéder aux valeurs et aux "controls" via la propriété associée.
								<br><br>
								<pre><code>import { FormGroup, FormControl } from "@angular/forms";
export class UserFormComponent {
	userForm = new FormGroup({
		title: new FormControl(),
		description: new FormControl()
	});
	submitUser() {
		console.log(this.userForm.value);
	}
}</code></pre>

								<pre><code>&lt;input
	type="text"
	[formControl]="userForm.controls.title">
&lt;textarea [formControl]="userForm.controls.description">&lt;/textarea>
&lt;button
	type="submit"
	(click)="submitUser()">SUBMIT&lt;/button></code></pre>

								L'objet <b>this.userForm.value</b> présente l'ensemble des valeurs des controls via un
								"plain objet" : <b>{title: 'TITLE', description: null}</b>

								<br><br>
								Il est également possibnle de faire une arborescence de <b>FormGroups</b> afin de
								regrouper
								différentes parties d'un formulaire de taille importante ou dont des parties sont
								réutilisables dans d'autres contextes.

								<br><br>

								<pre><code>new FormGroup({
	address : new FormGroup({
		street : new FormControl()
	})
});
</code></pre>

								<h5>Validator</h5>
								Les constructeurs des "controls" (FormControl, FormGroup et FormArray) acceptent en
								<b>second paramètre</b> une liste de fonctions de validation
								appelées <b>"validators"</b>.<br>
								Les "validators" natifs d'Angular sont regroupés sous forme de méthodes statiques das la
								classe Validators.
								<br><br>
								<pre><code>import { FormGroup, FormControl, Validators } from "@angular/forms";
export class UserFormComponent {
	userForm = new FormGroup({
		title: new FormControl(null, [
			Validators.required
		]),
		description: new FormControl()
	});
	submitUser() {
		console.log(this.userForm.value);
	}
}
</code></pre>

								L'ajout du "validator" ne change pas le comportement du composant : la méthode
								<b>submit</b> continue à être
								appelée bien que la contrainte de validation ne soit pas respectée.<br>
								C'est au composant de décider de l'action à mener en fonction de l'état des « controls".
								<br><br>
								Les <b>"controls"</b> disposent d'une série de propriétés et de méthodes permettant d'en
								vérifier l'état :
								<br><br>
								<ul>
									<li><b>valid</b> : Valeur booléenne indiquant si le "control" est valide. Dans le
										cas d'un <b>FormGroup</b> ou <b>FormArray</b> , le "control" est valide si les
										"controls" qui le composent sont tous valides.</li>
									<li><b>errors</b> : "plain object" combinant les erreurs de tous les validateurs.
										Vaut <b>null</b> si le "control" est valide.</li>
									<li><b>touched </b>: Valeur booléenne positionnée à true dès le déclenchement de
										l'événement blur (i.e. l'utilisateur change de « focus").</li>
									<li><b>pristine</b> : Valeur booléenne indiquant si le "control" a été modifié.</li>
								</ul>

								<pre><code>&lt;button [disabled]="!userForm.valid" type="submit" class="btn btn-success">SUBMIT&lt;/button></code></pre>
						</p>

						<h4>Route Guards</h4>
						<p>Les <b>"Guards"</b> permettent de contrôler l'accès à une "route" (e.g. <b>autorisation</b>)
							ou le départ depuis une "route" (e.g.
							enregistrement ou publication obligatoire avant départ).
							<br><br>
							<b>Attention</b> : Les "Guards" ne doivent en aucun cas être considérés comme un mécanisme
							de
							sécurité.
							La gestion de permission des accès aux ressources doit se faire au niveau des APIs HTTP.
							<br><br>

							Les "Guards" servent à améliorer la "User eXperience" en évitant par exemple l'accès à des
							"routes" qui ne fonctionneraient
							pas car l'accès aux données serait rejeté par l’API.

							<br><br>
							Ils sont ajoutés au niveau de la configuration du "Routing"

							<br><br>

							Création d'un guard :
							<code>ng g guard nom_guard</code>

							<h5>Configuration</h5>

							Les "Guards" sont ajoutés au niveau de la configuration du "Routing" :
							<br><br>
							<pre><code>export const appRouteList = [
{
	path: 'cart',
	loadChildren: './views/cart/cart-routing.module#CartRoutingModule',
	canActivate: [
		IsSignedInGuard
	]
	},
	{
		path: 'signin',
		component: SigninViewComponent,
		canActivate: [
			IsNotSignedInGuard
		]
	},
	{
		path: 'profile',
		component: ProfileViewComponent,
		canDeactivate: [
			IsNotDirtyGuard
		]
	}
]</code></pre>

							<h5>CanActivate</h5>

							Une "Guard" d'activation est un service qui implémente l'<b>interface</b>
							CanActivate.<br><br>
							Ce service doit donc implémenter la méthode <b>canActivate</b>.<br><br>
							Cette méthode est appelée à chaque demande d'accès à la "route" ; elle doit alors retourner
							une valeur de type boolean ou Promise&lt;boolean> ou Observable&lt;boolean>
									indiquant si l'accès à la "route" est autorisé ou non.
									Il est donc possible d'attendre le résultat d'un traitement asynchrone pour décider
									d'autoriser l'accès ou non.

							<br><br>
							Il est donc possible d'attendre le résultat d'un traitement asynchrone pour décider
							d'autoriser l'accès ou non.

<pre><code>
	@Injectable({
		providedIn: 'root'
	})
	export class IsSignedInGuard implements CanActivate {
	
		constructor(private _session: Session) {
		}
	
		canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
			return this._session.isSignedIn();
		}
	
	}

</code></pre>

https://guide-angular.wishtack.io/angular/routing/route-guards

						</p>


						<h4>Composants et services</h4>
						<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Magni repudiandae, illum alias sunt
							iste at earum nesciunt facilis nemo corrupti natus. Nisi maiores expedita soluta incidunt id
							repellat velit aut!</p>
						<h4>Observables et Rxjs</h4>
						<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Magni repudiandae, illum alias sunt
							iste at earum nesciunt facilis nemo corrupti natus. Nisi maiores expedita soluta incidunt id
							repellat velit aut!</p>
						<h4>Routing</h4>
						<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Magni repudiandae, illum alias sunt
							iste at earum nesciunt facilis nemo corrupti natus. Nisi maiores expedita soluta incidunt id
							repellat velit aut!</p>
						<h4>HTTP</h4>
						<p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Magni repudiandae, illum alias sunt
							iste at earum nesciunt facilis nemo corrupti natus. Nisi maiores expedita soluta incidunt id
							repellat velit aut!</p>

				</div>

			</article>
		</div>
	</section>



	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.scrolly.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/skel.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

</body>

</html>